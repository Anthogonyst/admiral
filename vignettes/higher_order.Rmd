---
title: "Higher Order Functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Higher Order Functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

This vignette explains some of the more advanced options of `{admiral}` related
to higher order functions. A higher order function is a function that takes another
function as input. By introducing these higher order functions, we intend to give
the user greater power over our derivation functions, whilst trying to negate the
need for adding additional `{admiral}` functions or arguments, or the user needing
many separate steps.

The functions covered here are:
- `call_derivation()`: Call a single derivation multiple times with some
parameters/arguments being fixed across iterations and others varying
- `restrict_derivation()`: Execute a derivation on a subset of the input dataset
- `slice_derivation()`: The input dataset is split into slices (subsets) and for
each slice the derivation is called separately. Some or all arguments of the
derivation may vary depending on the slice.

All examples show how a user may achieve the results without using these higher
order functions and then how by using these the calls could be simplified.

## Required Packages

The examples of this vignette require the following packages.

For example purpose, the CDISC Pilot SDTM datasets---which are included in
`{admiral.test}`---are used.

```{r, warning=FALSE, message=FALSE}
library(admiral)
library(admiral.test)
library(tibble)
library(dplyr)

data("admiral_vs")
vs <- admiral_vs
vs <- convert_blanks_to_na(vs)
```
```{r echo=FALSE}
vs <- filter(vs, USUBJID %in% c("01-701-1015", "01-701-1023"))
```

# call_derivation

This function exists purely for convenience to save the user repeating numerous
similar derivation function calls. It is best used when multiple derived variables
have very similar specifications with only slight variations.

As an example, imagine the case where all the parameters in a BDS ADaM required
both a highest value flag and a lowest value flag.

Here is an example of how to achieve this *WITHOUT* using `call_derivation()`: 

```{r}
vs_without <- vs %>%
  derive_var_extreme_flag(
    dataset,
    by_vars = vars(USUBJID, VSTESTCD),
    order = vars(AVAL),
    new_var = AHIFL,
    mode = "last"
  ) %>%
  derive_var_extreme_flag(
    dataset,
    by_vars = vars(USUBJID, VSTESTCD),
    order = vars(AVAL),
    new_var = ALOFL,
    mode = "first"
  )
```

```{r, eval=TRUE, echo=FALSE}
dataset_vignette(
  vs_without,
  display_vars = vars(USUBJID, VSTESTCD, AVAL, ALOFL, AHIFL),
  filter = VSTESTCD %in% c("TEMP", "WGT")
)
```

Here is an example of how to achieve the same *WITH* using `call_derivation()`: 

```{r}
vs_with <- vs %>%
  call_derivation(
    derivation = derive_var_extreme_flag,
    variable_params = list(
      params(new_var = AHIFL, mode = "last"),
      params(new_var = ALOFL, mode = "first")
    ),
    by_vars = vars(USUBJID, VSTESTCD),
    order = vars(AVAL),
  )
```

```{r, eval=TRUE, echo=FALSE}
dataset_vignette(
  vs_with,
  display_vars = vars(USUBJID, VSTESTCD, AVAL, ALOFL, AHIFL),
  filter = VSTESTCD %in% c("TEMP", "WGT")
)
```

The benefits of this higher order function would be further highlighted with
examples where more than two variable derivations had similar needs.
Developing your ADaM code this way would be more efficient and readable,
maintenance would be eased in case of specification changes, and downstream
quality checking would require less effort.

